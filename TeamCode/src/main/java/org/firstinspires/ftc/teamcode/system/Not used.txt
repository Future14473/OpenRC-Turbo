package org.firstinspires.ftc.teamcode.system

import org.firstinspires.ftc.teamcode.ROBOT_LOOP_PERIOD
import org.firstinspires.ftc.teamcode.hardware.Hardware
import org.futurerobotics.botsystem.Element
import org.futurerobotics.botsystem.LoopElement
import org.futurerobotics.jargon.linalg.Vec
import org.futurerobotics.jargon.linalg.get
import org.futurerobotics.jargon.linalg.zeroVec
import org.futurerobotics.jargon.math.MotionState
import org.futurerobotics.jargon.math.Pose2d
import org.futurerobotics.jargon.statespace.DiscreteStateSpaceMatrices
import org.futurerobotics.jargon.statespace.ExperimentalStateSpace
import org.futurerobotics.jargon.statespace.StateSpaceObserver
import org.futurerobotics.jargon.statespace.StateSpaceRunner
import kotlin.math.pow


// HEY BEN IN THE FUTURE:
// FIXME
//  So i found a problem with the "experimental" state space runner thing.
//  Very hard to mix and match parts.
//  Maybe use that declarative programming thing you were thinking about. BUT
//  LIKE ACTUALLY THINK ABOUT IT so you don't revise it 8 times
class ManualObserver : StateSpaceObserver {

    override var currentState: Vec = zeroVec(3)

    override fun reset(initialState: Vec) {
        //so, I guess, this ain't gonna work
    }

    override fun update(matrices: DiscreteStateSpaceMatrices, u: Vec, y: Vec, timeInNanos: Long): Vec {
        return currentState
    }
}


interface DriveVelocity : Element {
    val velocity: MotionState<Pose2d>
}

@UseExperimental(ExperimentalStateSpace::class)
class DriveController : LoopElement() {
    init {
        loopOn<ControlLoop>()
    }

    private val hardware by dependency<Hardware>()
    private val targetVelocity by dependency<DriveVelocity>()
    private val actualVelocity by dependency<BotVelocity>()
    private val observer: ManualObserver
    private val runner: StateSpaceRunner

    init {
        val (observer, runner) = DriveModel.getSSRunner()
        this.runner = runner
        this.observer = observer
    }


    override fun loop() {
        observer.currentState = actualVelocity.value
        val state = targetVelocity.velocity
        val period = ROBOT_LOOP_PERIOD
        val r = state.value
        val r1 = state.value + state.velocity * period + state.acceleration * (0.5 * period.pow(2))
        runner.update(
            dummy,
            r.toVec(),
            r1.toVec(),
            0L
        )
        repeat(4) { i ->
            hardware.wheelMotors!![i].voltage = runner.signal[i]
        }
    }

    companion object {
        private val dummy = zeroVec(1)
    }
}
